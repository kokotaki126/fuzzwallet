{"version":3,"sources":["../../src/core/crypto/webauthn.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport { Signature } from \"./asymmetricCrypto\";\nimport { Deserializer, Serializer } from \"../../bcs\";\nimport { Hex } from \"../hex\";\nimport { AssertionSignatureVariant, HexInput } from \"../../types\";\nimport { Secp256r1Signature } from \"./secp256r1\";\n\nexport class AssertionSignature extends Signature {\n  public readonly signature: Signature;\n\n  constructor(signature: Signature) {\n    super();\n    this.signature = signature;\n  }\n\n  /**\n   * Get the signature in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the signature\n   */\n  toUint8Array(): Uint8Array {\n    return this.signature.toUint8Array();\n  }\n\n  /**\n   * Get the signature as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the signature\n   */\n  toString(): string {\n    return this.signature.toString();\n  }\n\n  serialize(serializer: Serializer): void {\n    if (this.signature instanceof Secp256r1Signature) {\n      serializer.serializeU32AsUleb128(AssertionSignatureVariant.Secp256r1);\n      this.signature.serialize(serializer);\n    } else {\n      throw new Error(\"Unknown signature type for AssertionSignature\");\n    }\n  }\n\n  static deserialize(deserializer: Deserializer): AssertionSignature {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case AssertionSignatureVariant.Secp256r1:\n        return new AssertionSignature(Secp256r1Signature.load(deserializer));\n      default:\n        throw new Error(`Unknown variant index for AssertionSignature: ${index}`);\n    }\n  }\n}\n\nexport class PartialAuthenticatorAssertionResponse {\n  readonly signature: AssertionSignature;\n\n  readonly authenticatorData: Uint8Array;\n\n  readonly clientDataJSON: Uint8Array;\n\n  constructor(signature: Signature, authenticatorData: HexInput, clientDataJSON: HexInput) {\n    this.signature = new AssertionSignature(signature);\n\n    this.authenticatorData = Hex.fromHexInput(authenticatorData).toUint8Array();\n\n    this.clientDataJSON = Hex.fromHexInput(clientDataJSON).toUint8Array();\n  }\n}\n\nexport type ClientDataJSON = {\n  type: string;\n  challenge: string;\n  origin: string;\n  crossOrigin?: boolean;\n  tokenBinding?: {\n    id?: string;\n    status: \"present\" | \"supported\" | \"not-supported\";\n  };\n};\n\n/**\n * A signature of WebAuthn transaction\n */\nexport class WebAuthnSignature extends Signature {\n  /**\n   * The signature bytes\n   */\n  readonly paar: PartialAuthenticatorAssertionResponse;\n\n  /**\n   * Create a new Signature instance from a Uint8Array or String.\n   *\n   * @param hexInput A HexInput (string or Uint8Array)\n   */\n  constructor(signature: Signature, authenticatorData: HexInput, clientDataJSON: HexInput) {\n    super();\n\n    this.paar = new PartialAuthenticatorAssertionResponse(signature, authenticatorData, clientDataJSON);\n  }\n\n  /**\n   * Get the signature in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the signature\n   */\n  toUint8Array(): Uint8Array {\n    return this.paar.signature.toUint8Array();\n  }\n\n  /**\n   * Get the signature as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the signature\n   */\n  toString(): string {\n    return this.paar.toString();\n  }\n\n  getCollectedClientData(): ClientDataJSON {\n    const utf8Decoder = new TextDecoder(\"utf-8\");\n    const decodedClientData = utf8Decoder.decode(this.paar.clientDataJSON);\n    return JSON.parse(decodedClientData);\n  }\n\n  getVerificationData(): Uint8Array {\n    const clientDataJSONHash = sha256(this.paar.clientDataJSON);\n    const mergedArray = new Uint8Array(clientDataJSONHash.length + this.paar.authenticatorData.length);\n    mergedArray.set(this.paar.authenticatorData);\n    mergedArray.set(clientDataJSONHash, this.paar.authenticatorData.length);\n    return mergedArray;\n  }\n\n  serialize(serializer: Serializer): void {\n    this.paar.signature.serialize(serializer);\n    serializer.serializeBytes(this.paar.authenticatorData);\n    serializer.serializeBytes(this.paar.clientDataJSON);\n  }\n\n  static deserialize(deserializer: Deserializer): WebAuthnSignature {\n    const sig = AssertionSignature.deserialize(deserializer);\n    const authData = deserializer.deserializeBytes();\n    const clientDataJSON = deserializer.deserializeBytes();\n    return new WebAuthnSignature(sig.signature, authData, clientDataJSON);\n  }\n\n  static load(deserializer: Deserializer): WebAuthnSignature {\n    const sig = AssertionSignature.deserialize(deserializer);\n    const authData = deserializer.deserializeBytes();\n    const clientDataJSON = deserializer.deserializeBytes();\n    return new WebAuthnSignature(sig.signature, authData, clientDataJSON);\n  }\n}\n"],"mappings":"sHAGA,OAAS,UAAAA,MAAc,uBAOhB,IAAMC,EAAN,MAAMC,UAA2BC,CAAU,CAGhD,YAAYC,EAAsB,CAChC,MAAM,EACN,KAAK,UAAYA,CACnB,CAOA,cAA2B,CACzB,OAAO,KAAK,UAAU,aAAa,CACrC,CAOA,UAAmB,CACjB,OAAO,KAAK,UAAU,SAAS,CACjC,CAEA,UAAUC,EAA8B,CACtC,GAAI,KAAK,qBAAqBC,EAC5BD,EAAW,uBAAyD,EACpE,KAAK,UAAU,UAAUA,CAAU,MAEnC,OAAM,IAAI,MAAM,+CAA+C,CAEnE,CAEA,OAAO,YAAYE,EAAgD,CACjE,IAAMC,EAAQD,EAAa,wBAAwB,EACnD,OAAQC,EAAO,CACb,OACE,OAAO,IAAIN,EAAmBI,EAAmB,KAAKC,CAAY,CAAC,EACrE,QACE,MAAM,IAAI,MAAM,iDAAiDC,CAAK,EAAE,CAC5E,CACF,CACF,EAEaC,EAAN,KAA4C,CAOjD,YAAYL,EAAsBM,EAA6BC,EAA0B,CACvF,KAAK,UAAY,IAAIV,EAAmBG,CAAS,EAEjD,KAAK,kBAAoBQ,EAAI,aAAaF,CAAiB,EAAE,aAAa,EAE1E,KAAK,eAAiBE,EAAI,aAAaD,CAAc,EAAE,aAAa,CACtE,CACF,EAgBaE,EAAN,MAAMC,UAA0BX,CAAU,CAW/C,YAAYC,EAAsBM,EAA6BC,EAA0B,CACvF,MAAM,EAEN,KAAK,KAAO,IAAIF,EAAsCL,EAAWM,EAAmBC,CAAc,CACpG,CAOA,cAA2B,CACzB,OAAO,KAAK,KAAK,UAAU,aAAa,CAC1C,CAOA,UAAmB,CACjB,OAAO,KAAK,KAAK,SAAS,CAC5B,CAEA,wBAAyC,CAEvC,IAAMI,EADc,IAAI,YAAY,OAAO,EACL,OAAO,KAAK,KAAK,cAAc,EACrE,OAAO,KAAK,MAAMA,CAAiB,CACrC,CAEA,qBAAkC,CAChC,IAAMC,EAAqBC,EAAO,KAAK,KAAK,cAAc,EACpDC,EAAc,IAAI,WAAWF,EAAmB,OAAS,KAAK,KAAK,kBAAkB,MAAM,EACjG,OAAAE,EAAY,IAAI,KAAK,KAAK,iBAAiB,EAC3CA,EAAY,IAAIF,EAAoB,KAAK,KAAK,kBAAkB,MAAM,EAC/DE,CACT,CAEA,UAAUb,EAA8B,CACtC,KAAK,KAAK,UAAU,UAAUA,CAAU,EACxCA,EAAW,eAAe,KAAK,KAAK,iBAAiB,EACrDA,EAAW,eAAe,KAAK,KAAK,cAAc,CACpD,CAEA,OAAO,YAAYE,EAA+C,CAChE,IAAMY,EAAMlB,EAAmB,YAAYM,CAAY,EACjDa,EAAWb,EAAa,iBAAiB,EACzCI,EAAiBJ,EAAa,iBAAiB,EACrD,OAAO,IAAIO,EAAkBK,EAAI,UAAWC,EAAUT,CAAc,CACtE,CAEA,OAAO,KAAKJ,EAA+C,CACzD,IAAMY,EAAMlB,EAAmB,YAAYM,CAAY,EACjDa,EAAWb,EAAa,iBAAiB,EACzCI,EAAiBJ,EAAa,iBAAiB,EACrD,OAAO,IAAIO,EAAkBK,EAAI,UAAWC,EAAUT,CAAc,CACtE,CACF","names":["sha256","AssertionSignature","_AssertionSignature","Signature","signature","serializer","Secp256r1Signature","deserializer","index","PartialAuthenticatorAssertionResponse","authenticatorData","clientDataJSON","Hex","WebAuthnSignature","_WebAuthnSignature","decodedClientData","clientDataJSONHash","sha256","mergedArray","sig","authData"]}