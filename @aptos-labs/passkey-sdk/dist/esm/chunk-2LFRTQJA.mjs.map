{"version":3,"sources":["../../src/transactions/transactionBuilder/transactionBuilder.ts","../../src/internal/transactionSubmission.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file handles the transaction creation lifecycle.\n * It holds different operations to generate a transaction payload, a raw transaction,\n * and a signed transaction that can be simulated, signed and submitted to chain.\n */\nimport { sha3_256 as sha3Hash } from \"@noble/hashes/sha3\";\nimport { isoBase64URL } from \"@simplewebauthn/server/helpers\";\nimport { p256 } from \"@noble/curves/p256\";\nimport { base64URLStringToBuffer, startAuthentication } from \"@simplewebauthn/browser\";\nimport { generateAuthenticationOptions } from \"@simplewebauthn/server\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { AccountAddress, AccountAddressInput, Hex, PublicKey } from \"../../core\";\nimport { Account } from \"../../core/account\";\nimport { AnyPublicKey } from \"../../core/crypto/anyPublicKey\";\nimport { AnySignature } from \"../../core/crypto/anySignature\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"../../core/crypto/ed25519\";\nimport { Secp256k1PublicKey, Secp256k1Signature } from \"../../core/crypto/secp256k1\";\nimport { Secp256r1PublicKey, Secp256r1Signature } from \"../../core/crypto/secp256r1\";\nimport { getInfo } from \"../../internal/account\";\nimport { getLedgerInfo } from \"../../internal/general\";\nimport { getGasPriceEstimation } from \"../../internal/transaction\";\nimport { NetworkToChainId } from \"../../utils/apiEndpoints\";\nimport {\n  DEFAULT_MAX_GAS_AMOUNT,\n  DEFAULT_TXN_EXP_SEC_FROM_NOW,\n  RAW_TRANSACTION_SALT,\n  RAW_TRANSACTION_WITH_DATA_SALT,\n} from \"../../utils/const\";\nimport {\n  AccountAuthenticator,\n  AccountAuthenticatorEd25519,\n  AccountAuthenticatorMultiKey,\n  AccountAuthenticatorSingleKey,\n} from \"../authenticator/account\";\nimport {\n  TransactionAuthenticatorEd25519,\n  TransactionAuthenticatorFeePayer,\n  TransactionAuthenticatorMultiAgent,\n  TransactionAuthenticatorSingleSender,\n} from \"../authenticator/transaction\";\nimport {\n  ChainId,\n  EntryFunction,\n  FeePayerRawTransaction,\n  MultiAgentRawTransaction,\n  MultiSig,\n  MultiSigTransactionPayload,\n  RawTransaction,\n  Script,\n  TransactionPayloadEntryFunction,\n  TransactionPayloadMultiSig,\n  TransactionPayloadScript,\n} from \"../instances\";\nimport { SignedTransaction } from \"../instances/signedTransaction\";\nimport {\n  AnyRawTransaction,\n  AnyTransactionPayloadInstance,\n  AnyRawTransactionInstance,\n  EntryFunctionArgumentTypes,\n  EntryFunctionABI,\n  InputGenerateMultiAgentRawTransactionArgs,\n  InputGenerateRawTransactionArgs,\n  InputGenerateSingleSignerRawTransactionArgs,\n  SimpleTransaction,\n  InputGenerateTransactionOptions,\n  MultiAgentTransaction,\n  InputScriptData,\n  InputSimulateTransactionData,\n  InputGenerateTransactionPayloadData,\n  InputEntryFunctionData,\n  InputMultiSigData,\n  InputMultiSigDataWithRemoteABI,\n  InputEntryFunctionDataWithRemoteABI,\n  InputGenerateTransactionPayloadDataWithRemoteABI,\n  InputSubmitTransactionData,\n} from \"../types\";\nimport { convertArgument, fetchEntryFunctionAbi, standardizeTypeTags } from \"./remoteAbi\";\nimport { memoizeAsync } from \"../../utils/memoize\";\nimport { AnyNumber, HexInput, SigningScheme } from \"../../types\";\nimport { getFunctionParts, isScriptDataInput } from \"./helpers\";\nimport { WebAuthnSignature } from \"../../core/crypto/webauthn\";\nimport { getSigningMessage } from \"../../internal/transactionSubmission\";\n\n/**\n * We are defining function signatures, each with its specific input and output.\n * These are the possible function signature for our `generateTransactionPayload` function.\n * When we call our `generateTransactionPayload` function with the relevant type properties,\n * Typescript can infer the return type based on the appropriate function overload.\n */\nexport async function generateTransactionPayload(args: InputScriptData): Promise<TransactionPayloadScript>;\nexport async function generateTransactionPayload(\n  args: InputEntryFunctionDataWithRemoteABI,\n): Promise<TransactionPayloadEntryFunction>;\nexport async function generateTransactionPayload(\n  args: InputMultiSigDataWithRemoteABI,\n): Promise<TransactionPayloadMultiSig>;\n\n/**\n * Builds a transaction payload based on the data argument and returns\n * a transaction payload - TransactionPayloadScript | TransactionPayloadMultiSig | TransactionPayloadEntryFunction\n *\n * This uses the RemoteABI by default, and the remote ABI can be skipped by using generateTransactionPayloadWithABI\n *\n * @param args.data GenerateTransactionPayloadData\n *\n * @return TransactionPayload\n */\nexport async function generateTransactionPayload(\n  args: InputGenerateTransactionPayloadDataWithRemoteABI,\n): Promise<AnyTransactionPayloadInstance> {\n  if (isScriptDataInput(args)) {\n    return generateTransactionPayloadScript(args);\n  }\n\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);\n\n  // We fetch the entry function ABI, and then pretend that we already had the ABI\n  const functionAbi = await memoizeAsync(\n    async () => fetchEntryFunctionAbi(moduleAddress, moduleName, functionName, args.aptosConfig),\n    `entry-function-${args.aptosConfig.network}-${moduleAddress}-${moduleName}-${functionName}`,\n    1000 * 60 * 5, // 5 minutes\n  )();\n\n  return generateTransactionPayloadWithABI(args, functionAbi);\n}\n\nexport function generateTransactionPayloadWithABI(\n  args: InputEntryFunctionData,\n  functionAbi: EntryFunctionABI,\n): TransactionPayloadEntryFunction;\nexport function generateTransactionPayloadWithABI(\n  args: InputMultiSigData,\n  functionAbi: EntryFunctionABI,\n): TransactionPayloadMultiSig;\nexport function generateTransactionPayloadWithABI(\n  args: InputGenerateTransactionPayloadData,\n  functionAbi: EntryFunctionABI,\n): AnyTransactionPayloadInstance {\n  if (isScriptDataInput(args)) {\n    return generateTransactionPayloadScript(args);\n  }\n\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);\n\n  // Ensure that all type arguments are typed properly\n  const typeArguments = standardizeTypeTags(args.typeArguments);\n\n  // Check the type argument count against the ABI\n  if (typeArguments.length !== functionAbi.typeParameters.length) {\n    throw new Error(\n      `Type argument count mismatch, expected ${functionAbi.typeParameters.length}, received ${typeArguments.length}`,\n    );\n  }\n\n  // Check all BCS types, and convert any non-BCS types\n  const functionArguments: Array<EntryFunctionArgumentTypes> = args.functionArguments.map((arg, i) =>\n    convertArgument(args.function, functionAbi, arg, i, typeArguments),\n  );\n\n  // Check that all arguments are accounted for\n  if (functionArguments.length !== functionAbi.parameters.length) {\n    throw new Error(\n      // eslint-disable-next-line max-len\n      `Too few arguments for '${moduleAddress}::${moduleName}::${functionName}', expected ${functionAbi.parameters.length} but got ${functionArguments.length}`,\n    );\n  }\n\n  // Generate entry function payload\n  const entryFunctionPayload = EntryFunction.build(\n    `${moduleAddress}::${moduleName}`,\n    functionName,\n    typeArguments,\n    functionArguments,\n  );\n\n  // Send it as multi sig if it's a multisig payload\n  if (\"multisigAddress\" in args) {\n    const multisigAddress = AccountAddress.from(args.multisigAddress);\n    return new TransactionPayloadMultiSig(\n      new MultiSig(multisigAddress, new MultiSigTransactionPayload(entryFunctionPayload)),\n    );\n  }\n\n  // Otherwise send as an entry function\n  return new TransactionPayloadEntryFunction(entryFunctionPayload);\n}\n\nfunction generateTransactionPayloadScript(args: InputScriptData) {\n  return new TransactionPayloadScript(\n    new Script(Hex.fromHexInput(args.bytecode).toUint8Array(), args.typeArguments ?? [], args.functionArguments),\n  );\n}\n\n/**\n * Generates a raw transaction\n *\n * @param args.aptosConfig AptosConfig\n * @param args.sender The transaction's sender account address as a hex input\n * @param args.payload The transaction payload - can create by using generateTransactionPayload()\n *\n * @returns RawTransaction\n */\nexport async function generateRawTransaction(args: {\n  aptosConfig: AptosConfig;\n  sender: AccountAddressInput;\n  payload: AnyTransactionPayloadInstance;\n  options?: InputGenerateTransactionOptions;\n  feePayerAddress?: AccountAddressInput;\n}): Promise<RawTransaction> {\n  const { aptosConfig, sender, payload, options, feePayerAddress } = args;\n\n  const getChainId = NetworkToChainId[aptosConfig.network]\n    ? Promise.resolve({ chain_id: NetworkToChainId[aptosConfig.network] })\n    : getLedgerInfo({ aptosConfig });\n\n  const getGasUnitPrice = options?.gasUnitPrice\n    ? Promise.resolve({ gas_estimate: options.gasUnitPrice })\n    : getGasPriceEstimation({ aptosConfig });\n\n  const [{ chain_id: chainId }, { gas_estimate: gasEstimate }] = await Promise.all([getChainId, getGasUnitPrice]);\n\n  const getSequenceNumber =\n    options?.accountSequenceNumber !== undefined\n      ? Promise.resolve({ sequence_number: options.accountSequenceNumber })\n      : getInfo({ aptosConfig, accountAddress: sender });\n\n  let sequenceNumber: string | AnyNumber;\n\n  /**\n   * Check if is sponsored transaction to honor AIP-52\n   * {@link https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-52.md}\n   */\n  if (feePayerAddress && AccountAddress.from(feePayerAddress).equals(AccountAddress.ZERO)) {\n    // Handle sponsored transaction generation with the option that\n    // the main signer has not been created on chain\n    try {\n      // Check if main signer has been created on chain, if not assign sequence number 0\n      const { sequence_number: seqNumber } = await getSequenceNumber;\n      sequenceNumber = seqNumber;\n    } catch (e: any) {\n      sequenceNumber = \"0\";\n    }\n  } else {\n    const { sequence_number: seqNumber } = await getSequenceNumber;\n    sequenceNumber = seqNumber;\n  }\n\n  const { maxGasAmount, gasUnitPrice, expireTimestamp } = {\n    maxGasAmount: options?.maxGasAmount ? BigInt(options.maxGasAmount) : BigInt(DEFAULT_MAX_GAS_AMOUNT),\n    gasUnitPrice: BigInt(gasEstimate),\n    expireTimestamp: BigInt(Math.floor(Date.now() / 1000) + DEFAULT_TXN_EXP_SEC_FROM_NOW),\n    ...options,\n  };\n\n  return new RawTransaction(\n    AccountAddress.from(sender),\n    BigInt(sequenceNumber),\n    payload,\n    BigInt(maxGasAmount),\n    BigInt(gasUnitPrice),\n    BigInt(expireTimestamp),\n    new ChainId(chainId),\n  );\n}\n\n/**\n * We are defining function signatures, each with its specific input and output.\n * These are the possible function signature for our `generateTransaction` function.\n * When we call our `generateTransaction` function with the relevant type properties,\n * Typescript can infer the return type based on the appropriate function overload.\n */\nexport async function buildTransaction(args: InputGenerateSingleSignerRawTransactionArgs): Promise<SimpleTransaction>;\nexport async function buildTransaction(args: InputGenerateMultiAgentRawTransactionArgs): Promise<MultiAgentTransaction>;\n\n/**\n * Generates a transaction based on the provided arguments\n *\n * Note: we can start with one function to support all different payload/transaction types,\n * and if to complex to use, we could have function for each type\n *\n * @param args.aptosConfig AptosConfig\n * @param args.sender The transaction's sender account address as a hex input\n * @param args.payload The transaction payload - can create by using generateTransactionPayload()\n * @param args.options optional. Transaction options object\n * @param args.secondarySignerAddresses optional. For when want to create a multi signers transaction\n * @param args.feePayerAddress optional. For when want to create a fee payer (aka sponsored) transaction\n *\n * @return An instance of a RawTransaction, plus optional secondary/fee payer addresses\n * ```\n * {\n *  rawTransaction: RawTransaction,\n *  secondarySignerAddresses? : Array<AccountAddress>,\n *  feePayerAddress?: AccountAddress\n * }\n * ```\n */\nexport async function buildTransaction(args: InputGenerateRawTransactionArgs): Promise<AnyRawTransaction> {\n  const { aptosConfig, sender, payload, options, feePayerAddress } = args;\n  // generate raw transaction\n  const rawTxn = await generateRawTransaction({\n    aptosConfig,\n    sender,\n    payload,\n    options,\n    feePayerAddress,\n  });\n\n  // if multi agent transaction\n  if (\"secondarySignerAddresses\" in args) {\n    const signers: Array<AccountAddress> =\n      args.secondarySignerAddresses?.map((signer) => AccountAddress.from(signer)) ?? [];\n\n    return {\n      rawTransaction: rawTxn,\n      secondarySignerAddresses: signers,\n      feePayerAddress: args.feePayerAddress ? AccountAddress.from(args.feePayerAddress) : undefined,\n    };\n  }\n  // return the raw transaction\n  return {\n    rawTransaction: rawTxn,\n    feePayerAddress: args.feePayerAddress ? AccountAddress.from(args.feePayerAddress) : undefined,\n  };\n}\n\n/**\n * Simulate a transaction before signing and submit to chain\n *\n * @param args.transaction A aptos transaction type to sign\n * @param args.signerPublicKey The signer public key\n * @param args.secondarySignersPublicKeys optional. The secondary signers public keys if multi signers transaction\n * @param args.feePayerPublicKey optional. The fee payer public key is a fee payer (aka sponsored) transaction\n * @param args.options optional. SimulateTransactionOptions\n *\n * @returns A signed serialized transaction that can be simulated\n */\nexport function generateSignedTransactionForSimulation(args: InputSimulateTransactionData): Uint8Array {\n  const { signerPublicKey, transaction, secondarySignersPublicKeys, feePayerPublicKey } = args;\n\n  const accountAuthenticator = getAuthenticatorForSimulation(signerPublicKey);\n\n  // fee payer transaction\n  if (transaction.feePayerAddress) {\n    const transactionToSign = new FeePayerRawTransaction(\n      transaction.rawTransaction,\n      transaction.secondarySignerAddresses ?? [],\n      transaction.feePayerAddress,\n    );\n    let secondaryAccountAuthenticators: Array<AccountAuthenticator> = [];\n    if (secondarySignersPublicKeys) {\n      secondaryAccountAuthenticators = secondarySignersPublicKeys.map((publicKey) =>\n        getAuthenticatorForSimulation(publicKey),\n      );\n    }\n    const feePayerAuthenticator = getAuthenticatorForSimulation(feePayerPublicKey!);\n\n    const transactionAuthenticator = new TransactionAuthenticatorFeePayer(\n      accountAuthenticator,\n      transaction.secondarySignerAddresses ?? [],\n      secondaryAccountAuthenticators,\n      {\n        address: transaction.feePayerAddress,\n        authenticator: feePayerAuthenticator,\n      },\n    );\n    return new SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator).bcsToBytes();\n  }\n\n  // multi agent transaction\n  if (transaction.secondarySignerAddresses) {\n    const transactionToSign = new MultiAgentRawTransaction(\n      transaction.rawTransaction,\n      transaction.secondarySignerAddresses,\n    );\n\n    let secondaryAccountAuthenticators: Array<AccountAuthenticator> = [];\n\n    secondaryAccountAuthenticators = secondarySignersPublicKeys!.map((publicKey) =>\n      getAuthenticatorForSimulation(publicKey),\n    );\n\n    const transactionAuthenticator = new TransactionAuthenticatorMultiAgent(\n      accountAuthenticator,\n      transaction.secondarySignerAddresses,\n      secondaryAccountAuthenticators,\n    );\n\n    return new SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator).bcsToBytes();\n  }\n\n  // single signer raw transaction\n  let transactionAuthenticator;\n  if (accountAuthenticator instanceof AccountAuthenticatorEd25519) {\n    transactionAuthenticator = new TransactionAuthenticatorEd25519(\n      accountAuthenticator.public_key,\n      accountAuthenticator.signature,\n    );\n  } else if (accountAuthenticator instanceof AccountAuthenticatorSingleKey) {\n    transactionAuthenticator = new TransactionAuthenticatorSingleSender(accountAuthenticator);\n  } else {\n    throw new Error(\"Invalid public key\");\n  }\n  return new SignedTransaction(transaction.rawTransaction, transactionAuthenticator).bcsToBytes();\n}\n\nexport function getAuthenticatorForSimulation(publicKey: PublicKey) {\n  // TODO add support for AnyMultiKey\n  if (publicKey instanceof AnyPublicKey) {\n    if (publicKey.publicKey instanceof Ed25519PublicKey) {\n      return new AccountAuthenticatorSingleKey(publicKey, new AnySignature(new Ed25519Signature(new Uint8Array(64))));\n    }\n    if (publicKey.publicKey instanceof Secp256k1PublicKey) {\n      return new AccountAuthenticatorSingleKey(publicKey, new AnySignature(new Secp256k1Signature(new Uint8Array(64))));\n    }\n  }\n\n  // legacy code\n  return new AccountAuthenticatorEd25519(\n    new Ed25519PublicKey(publicKey.toUint8Array()),\n    new Ed25519Signature(new Uint8Array(64)),\n  );\n}\n\n/**\n * Sign a transaction that can later be submitted to chain\n *\n * @param args.signer The signer account to sign the transaction\n * @param args.transaction A aptos transaction type to sign\n *\n * @return The signer AccountAuthenticator\n */\nexport function sign(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n  const { signer, transaction } = args;\n\n  // get the signing message\n  const message = generateSigningMessage(transaction);\n\n  // account.signMessage\n  const signerSignature = signer.sign(message);\n\n  // return account authentication\n  switch (signer.signingScheme) {\n    case SigningScheme.Ed25519:\n      return new AccountAuthenticatorEd25519(\n        new Ed25519PublicKey(signer.publicKey.toUint8Array()),\n        new Ed25519Signature(signerSignature.toUint8Array()),\n      );\n    case SigningScheme.SingleKey:\n      if (!AnyPublicKey.isPublicKey(signer.publicKey)) {\n        throw new Error(`Cannot sign transaction, public key does not match ${signer.signingScheme}`);\n      }\n      return new AccountAuthenticatorSingleKey(signer.publicKey, new AnySignature(signerSignature));\n    // TODO support MultiEd25519\n    default:\n      throw new Error(`Cannot sign transaction, signing scheme ${signer.signingScheme} not supported`);\n  }\n}\n\nexport async function signWithPasskey(args: {\n  publicKey: PublicKey;\n  credentialId: string | Uint8Array;\n  transaction: AnyRawTransaction;\n  timeout?: number;\n  rpID?: string;\n  options?: {\n    allowCredentials?: PublicKeyCredentialDescriptor[]\n  }\n}): Promise<AccountAuthenticator> {\n  const { credentialId, publicKey, transaction, timeout, rpID, options } = args;\n  console.log(\"PublicKey\", publicKey.toString());\n\n  if (!(publicKey instanceof Secp256r1PublicKey)) {\n    throw new Error(\"Unsupported public key for passkey signing.\");\n  }\n\n  const allowCredentials: PublicKeyCredentialDescriptor[] = options?.allowCredentials ?? [\n    {\n      type: \"public-key\",\n      id: typeof credentialId === \"string\" ? isoBase64URL.toBuffer(credentialId) : credentialId,\n    },\n  ];\n\n  // Get the signing message and hash it to create the challenge\n  const transactionToSign: SimpleTransaction = { rawTransaction: deriveTransactionType(transaction) as RawTransaction };\n  const signingMessage = getSigningMessage({ transaction: transactionToSign as AnyRawTransaction });\n  const challenge = sha3Hash(signingMessage);\n\n  const authOptions = await generateAuthenticationOptions({\n    allowCredentials,\n    challenge,\n    timeout,\n    rpID,\n    userVerification: \"required\",\n  });\n  const authenticationResponse = await startAuthentication(authOptions);\n\n  const authenticatorAssertionResponse = authenticationResponse.response;\n  console.log(authenticatorAssertionResponse);\n\n  const { clientDataJSON, authenticatorData, signature } = authenticatorAssertionResponse;\n\n  console.log(\"DER Signature: \", signature)\n  const signatureCompact = p256.Signature.fromDER(\n    new Uint8Array(base64URLStringToBuffer(signature)),\n  ).toCompactRawBytes();\n  \n  console.log(\"COMPACT Signature: \", new Hex(signatureCompact).toString());\n\n  const webAuthnSignature = new WebAuthnSignature(\n    new Secp256r1Signature(signatureCompact),\n    isoBase64URL.toBuffer(authenticatorData),\n    isoBase64URL.toBuffer(clientDataJSON),\n  );\n\n  console.log(\"WEBAUTHN Signature: \", webAuthnSignature);\n  return new AccountAuthenticatorSingleKey(new AnyPublicKey(publicKey), new AnySignature(webAuthnSignature));\n}\n\n/**\n * Creates and returns the Authenticator for passkey signed transactions.\n *\n * @param args.publicKey The public key of the passkey credential.\n * @param args.signature The P256signature which is the signed challenge.\n * @param args.authenticatorData The AuthenticatorData of the assertion.\n * @param args.clientDataJSON The clientDataJSON of the assertion.\n *\n * @return The signer AccountAuthenticator\n */\nexport function getAuthenticatorForWebAuthn(args: {\n  publicKey: PublicKey;\n  signature: HexInput;\n  authenticatorData: HexInput;\n  clientDataJSON: HexInput;\n}): AccountAuthenticator {\n  const { publicKey, signature, authenticatorData, clientDataJSON } = args;\n  let signatureObj: AnySignature;\n  if (publicKey instanceof Secp256r1PublicKey) {\n    signatureObj = new AnySignature(new Secp256r1Signature(signature));\n  } else {\n    throw new Error(\"Unsupported public key\");\n  }\n  const webAuthnSignature = new WebAuthnSignature(signatureObj, authenticatorData, clientDataJSON);\n  return new AccountAuthenticatorSingleKey(new AnyPublicKey(publicKey), new AnySignature(webAuthnSignature));\n}\n\n/**\n * Prepare a transaction to be submitted to chain\n *\n * @param args.transaction A aptos transaction type\n * @param args.senderAuthenticator The account authenticator of the transaction sender\n * @param args.secondarySignerAuthenticators optional. For when the transaction is a multi signers transaction\n *\n * @returns A SignedTransaction\n */\nexport function generateSignedTransaction(args: InputSubmitTransactionData): Uint8Array {\n  const { transaction, senderAuthenticator, feePayerAuthenticator, additionalSignersAuthenticators } = args;\n\n  const transactionToSubmit = deriveTransactionType(transaction);\n\n  if (\n    (feePayerAuthenticator || additionalSignersAuthenticators) &&\n    (transactionToSubmit instanceof MultiAgentRawTransaction || transactionToSubmit instanceof FeePayerRawTransaction)\n  ) {\n    return generateMultiSignersSignedTransaction(\n      transactionToSubmit,\n      senderAuthenticator,\n      feePayerAuthenticator,\n      additionalSignersAuthenticators,\n    );\n  }\n\n  // submit single signer transaction\n\n  // check what instance is accountAuthenticator\n  if (senderAuthenticator instanceof AccountAuthenticatorEd25519 && transactionToSubmit instanceof RawTransaction) {\n    const transactionAuthenticator = new TransactionAuthenticatorEd25519(\n      senderAuthenticator.public_key,\n      senderAuthenticator.signature,\n    );\n    return new SignedTransaction(transactionToSubmit, transactionAuthenticator).bcsToBytes();\n  }\n\n  if (\n    (senderAuthenticator instanceof AccountAuthenticatorSingleKey ||\n      senderAuthenticator instanceof AccountAuthenticatorMultiKey) &&\n    transactionToSubmit instanceof RawTransaction\n  ) {\n    const transactionAuthenticator = new TransactionAuthenticatorSingleSender(senderAuthenticator);\n    return new SignedTransaction(transactionToSubmit, transactionAuthenticator).bcsToBytes();\n  }\n\n  throw new Error(\n    `Cannot generate a signed transaction, ${senderAuthenticator} is not a supported account authentication scheme`,\n  );\n}\n\n/**\n * Derive the raw transaction type - FeePayerRawTransaction or MultiAgentRawTransaction or RawTransaction\n *\n * @param transaction A aptos transaction type\n *\n * @returns FeePayerRawTransaction | MultiAgentRawTransaction | RawTransaction\n */\nexport function deriveTransactionType(transaction: AnyRawTransaction): AnyRawTransactionInstance {\n  if (transaction.feePayerAddress) {\n    return new FeePayerRawTransaction(\n      transaction.rawTransaction,\n      transaction.secondarySignerAddresses ?? [],\n      transaction.feePayerAddress,\n    );\n  }\n  if (transaction.secondarySignerAddresses) {\n    return new MultiAgentRawTransaction(transaction.rawTransaction, transaction.secondarySignerAddresses);\n  }\n\n  return transaction.rawTransaction;\n}\n\n/**\n * Generate a multi signers signed transaction that can be submitted to chain\n *\n * @param transaction MultiAgentRawTransaction | FeePayerRawTransaction\n * @param senderAuthenticator The account authenticator of the transaction sender\n * @param secondarySignerAuthenticators The extra signers account Authenticators\n *\n * @returns A SignedTransaction\n */\nexport function generateMultiSignersSignedTransaction(\n  transaction: MultiAgentRawTransaction | FeePayerRawTransaction,\n  senderAuthenticator: AccountAuthenticator,\n  feePayerAuthenticator?: AccountAuthenticator,\n  additionalSignersAuthenticators?: Array<AccountAuthenticator>,\n) {\n  if (transaction instanceof FeePayerRawTransaction) {\n    if (!feePayerAuthenticator) {\n      throw new Error(\"Must provide a feePayerAuthenticator argument to generate a signed fee payer transaction\");\n    }\n    const txAuthenticatorFeePayer = new TransactionAuthenticatorFeePayer(\n      senderAuthenticator,\n      transaction.secondary_signer_addresses,\n      additionalSignersAuthenticators ?? [],\n      {\n        address: transaction.fee_payer_address,\n        authenticator: feePayerAuthenticator,\n      },\n    );\n    return new SignedTransaction(transaction.raw_txn, txAuthenticatorFeePayer).bcsToBytes();\n  }\n  if (transaction instanceof MultiAgentRawTransaction) {\n    if (!additionalSignersAuthenticators) {\n      throw new Error(\n        \"Must provide a additionalSignersAuthenticators argument to generate a signed multi agent transaction\",\n      );\n    }\n    const multiAgentAuthenticator = new TransactionAuthenticatorMultiAgent(\n      senderAuthenticator,\n      transaction.secondary_signer_addresses,\n      additionalSignersAuthenticators ?? [],\n    );\n    return new SignedTransaction(transaction.raw_txn, multiAgentAuthenticator).bcsToBytes();\n  }\n\n  throw new Error(\n    `Cannot prepare multi signers transaction to submission, ${typeof transaction} transaction is not supported`,\n  );\n}\n\nexport function generateSigningMessage(transaction: AnyRawTransaction): Uint8Array {\n  const rawTxn = deriveTransactionType(transaction);\n  const hash = sha3Hash.create();\n\n  if (rawTxn instanceof RawTransaction) {\n    hash.update(RAW_TRANSACTION_SALT);\n  } else if (rawTxn instanceof MultiAgentRawTransaction) {\n    hash.update(RAW_TRANSACTION_WITH_DATA_SALT);\n  } else if (rawTxn instanceof FeePayerRawTransaction) {\n    hash.update(RAW_TRANSACTION_WITH_DATA_SALT);\n  } else {\n    throw new Error(`Unknown transaction type to sign on: ${rawTxn}`);\n  }\n\n  const prefix = hash.digest();\n\n  const body = rawTxn.bcsToBytes();\n\n  const mergedArray = new Uint8Array(prefix.length + body.length);\n  mergedArray.set(prefix);\n  mergedArray.set(body, prefix.length);\n\n  return mergedArray;\n}\n","/**\n * This file contains the underlying implementations for exposed submission API surface in\n * the {@link api/transaction}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * transaction namespace and without having a dependency cycle error.\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { MoveVector, U8 } from \"../bcs\";\nimport { postAptosFullNode } from \"../client\";\nimport { Account } from \"../core/account\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { PrivateKey } from \"../core/crypto\";\nimport { AccountAuthenticator } from \"../transactions/authenticator/account\";\nimport { RotationProofChallenge } from \"../transactions/instances/rotationProofChallenge\";\nimport {\n  buildTransaction,\n  generateTransactionPayload,\n  generateSignedTransactionForSimulation,\n  generateSignedTransaction,\n  sign,\n  generateSigningMessage,\n} from \"../transactions/transactionBuilder/transactionBuilder\";\nimport type {\n  InputGenerateTransactionData,\n  AnyRawTransaction,\n  InputSimulateTransactionData,\n  InputGenerateTransactionOptions,\n  SimpleTransaction,\n  InputGenerateTransactionPayloadDataWithRemoteABI,\n  InputSubmitTransactionData,\n  InputGenerateMultiAgentRawTransactionData,\n  InputGenerateSingleSignerRawTransactionData,\n  MultiAgentTransaction,\n  AnyTransactionPayloadInstance,\n} from \"../transactions/types\";\nimport { getInfo } from \"./account\";\nimport { UserTransactionResponse, PendingTransactionResponse, MimeType, HexInput, TransactionResponse } from \"../types\";\n\n/**\n * We are defining function signatures, each with its specific input and output.\n * These are the possible function signature for `generateTransaction` function.\n * When we call `generateTransaction` function with the relevant type properties,\n * Typescript can infer the return type based on the appropriate function overload.\n */\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateSingleSignerRawTransactionData,\n): Promise<SimpleTransaction>;\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateMultiAgentRawTransactionData,\n): Promise<MultiAgentTransaction>;\n/**\n * Generates any transaction by passing in the required arguments\n *\n * @param args.sender The transaction sender's account address as a AccountAddressInput\n * @param args.data EntryFunctionData | ScriptData | MultiSigData\n * @param args.feePayerAddress optional. For a fee payer (aka sponsored) transaction\n * @param args.secondarySignerAddresses optional. For a multi-agent or fee payer (aka sponsored) transactions\n * @param args.options optional. GenerateTransactionOptions type\n *\n * @example\n * For a single signer entry function\n * move function name, move function type arguments, move function arguments\n * `\n * data: {\n *  function:\"0x1::aptos_account::transfer\",\n *  typeArguments:[]\n *  functionArguments :[receiverAddress,10]\n * }\n * `\n *\n * @example\n * For a single signer script function\n * module bytecode, move function type arguments, move function arguments\n * ```\n * data: {\n *  bytecode:\"0x001234567\",\n *  typeArguments:[],\n *  functionArguments :[receiverAddress,10]\n * }\n * ```\n *\n * @return An instance of a RawTransaction, plus optional secondary/fee payer addresses\n * ```\n * {\n *  rawTransaction: RawTransaction,\n *  secondarySignerAddresses? : Array<AccountAddress>,\n *  feePayerAddress?: AccountAddress\n * }\n * ```\n */\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateTransactionData,\n): Promise<AnyRawTransaction> {\n  const payload = await buildTransactionPayload(args);\n  return buildRawTransaction(args, payload);\n}\n\nexport async function buildTransactionPayload(\n  args: { aptosConfig: AptosConfig } & InputGenerateTransactionData,\n): Promise<AnyTransactionPayloadInstance> {\n  const { aptosConfig, data } = args;\n\n  // Merge in aptosConfig for remote ABI on non-script payloads\n  let generateTransactionPayloadData: InputGenerateTransactionPayloadDataWithRemoteABI;\n  let payload: AnyTransactionPayloadInstance;\n  if (\"bytecode\" in data) {\n    generateTransactionPayloadData = data;\n    payload = await generateTransactionPayload(generateTransactionPayloadData);\n  } else if (\"multisigAddress\" in data) {\n    generateTransactionPayloadData = {\n      aptosConfig,\n      multisigAddress: data.multisigAddress,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments,\n    };\n    payload = await generateTransactionPayload(generateTransactionPayloadData);\n  } else {\n    generateTransactionPayloadData = {\n      aptosConfig,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments,\n    };\n    payload = await generateTransactionPayload(generateTransactionPayloadData);\n  }\n  return payload;\n}\n\nexport async function buildRawTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateTransactionData,\n  payload: AnyTransactionPayloadInstance,\n): Promise<AnyRawTransaction> {\n  const { aptosConfig, sender, options } = args;\n\n  let feePayerAddress;\n  if (isFeePayerTransactionInput(args)) {\n    feePayerAddress = AccountAddress.ZERO.toString();\n  }\n\n  if (isMultiAgentTransactionInput(args)) {\n    const { secondarySignerAddresses } = args;\n    return buildTransaction({\n      aptosConfig,\n      sender,\n      payload,\n      options,\n      secondarySignerAddresses,\n      feePayerAddress,\n    });\n  }\n\n  return buildTransaction({\n    aptosConfig,\n    sender,\n    payload,\n    options,\n    feePayerAddress,\n  });\n}\n\nfunction isFeePayerTransactionInput(data: InputGenerateTransactionData): boolean {\n  return data.withFeePayer === true;\n}\n\nfunction isMultiAgentTransactionInput(\n  data: InputGenerateTransactionData,\n): data is InputGenerateMultiAgentRawTransactionData {\n  return \"secondarySignerAddresses\" in data;\n}\n\n/**\n * Builds a signing message that can be signed by external signers\n *\n * Note: Please prefer using `signTransaction` unless signing outside the SDK\n *\n * @param args.transaction AnyRawTransaction, as generated by `generateTransaction()`\n *\n * @return The message to be signed\n */\nexport function getSigningMessage(args: { transaction: AnyRawTransaction }): Uint8Array {\n  const { transaction } = args;\n  return generateSigningMessage(transaction);\n}\n\n/**\n * Sign a transaction that can later be submitted to chain\n *\n * @param args.signer The signer account to sign the transaction\n * @param args.transaction An instance of a RawTransaction, plus optional secondary/fee payer addresses\n * ```\n * {\n *  rawTransaction: RawTransaction,\n *  secondarySignerAddresses? : Array<AccountAddress>,\n *  feePayerAddress?: AccountAddress\n * }\n * ```\n *\n * @return The signer AccountAuthenticator\n */\nexport function signTransaction(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n  const accountAuthenticator = sign({ ...args });\n  return accountAuthenticator;\n}\n\n/**\n * Simulates a transaction before singing it.\n *\n * @param args.signerPublicKey The signer public key\n * @param args.transaction The raw transaction to simulate\n * @param args.secondarySignersPublicKeys optional. For when the transaction is a multi signers transaction\n * @param args.feePayerPublicKey optional. For when the transaction is a fee payer (aka sponsored) transaction\n * @param args.options optional. A config to simulate the transaction with\n */\nexport async function simulateTransaction(\n  args: { aptosConfig: AptosConfig } & InputSimulateTransactionData,\n): Promise<Array<UserTransactionResponse>> {\n  const { aptosConfig, transaction, signerPublicKey, secondarySignersPublicKeys, feePayerPublicKey, options } = args;\n\n  const signedTransaction = generateSignedTransactionForSimulation({\n    transaction,\n    signerPublicKey,\n    secondarySignersPublicKeys,\n    feePayerPublicKey,\n    options,\n  });\n\n  const { data } = await postAptosFullNode<Uint8Array, Array<UserTransactionResponse>>({\n    aptosConfig,\n    body: signedTransaction,\n    path: \"transactions/simulate\",\n    params: {\n      estimate_gas_unit_price: args.options?.estimateGasUnitPrice ?? false,\n      estimate_max_gas_amount: args.options?.estimateMaxGasAmount ?? false,\n      estimate_prioritized_gas_unit_price: args.options?.estimatePrioritizedGasUnitPrice ?? false,\n    },\n    originMethod: \"simulateTransaction\",\n    contentType: MimeType.BCS_SIGNED_TRANSACTION,\n  });\n  return data;\n}\n\n/**\n * Submit transaction to chain\n *\n * @param args.transaction A aptos transaction type\n * @param args.senderAuthenticator The account authenticator of the transaction sender\n * @param args.secondarySignerAuthenticators optional. For when the transaction is a multi signers transaction\n *\n * @return PendingTransactionResponse\n */\nexport async function submitTransaction(\n  args: {\n    aptosConfig: AptosConfig;\n  } & InputSubmitTransactionData,\n): Promise<PendingTransactionResponse> {\n  const { aptosConfig } = args;\n  const signedTransaction = generateSignedTransaction({ ...args });\n  const { data } = await postAptosFullNode<Uint8Array, PendingTransactionResponse>({\n    aptosConfig,\n    body: signedTransaction,\n    path: \"transactions\",\n    originMethod: \"submitTransaction\",\n    contentType: MimeType.BCS_SIGNED_TRANSACTION,\n  });\n  return data;\n}\n\nexport async function signAndSubmitTransaction(args: {\n  aptosConfig: AptosConfig;\n  signer: Account;\n  transaction: AnyRawTransaction;\n}): Promise<PendingTransactionResponse> {\n  const { aptosConfig, signer, transaction } = args;\n  const authenticator = signTransaction({ signer, transaction });\n  return submitTransaction({\n    aptosConfig,\n    transaction,\n    senderAuthenticator: authenticator,\n  });\n}\n\nexport async function publicPackageTransaction(args: {\n  aptosConfig: AptosConfig;\n  account: AccountAddressInput;\n  metadataBytes: HexInput;\n  moduleBytecode: Array<HexInput>;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, account, metadataBytes, moduleBytecode, options } = args;\n\n  const totalByteCode = moduleBytecode.map((bytecode) => MoveVector.U8(bytecode));\n\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: AccountAddress.from(account),\n    data: {\n      function: \"0x1::code::publish_package_txn\",\n      functionArguments: [MoveVector.U8(metadataBytes), new MoveVector(totalByteCode)],\n    },\n    options,\n  });\n  return transaction;\n}\n\n/**\n * TODO: Need to refactor and move this function out of transactionSubmission\n */\nexport async function rotateAuthKey(args: {\n  aptosConfig: AptosConfig;\n  fromAccount: Account;\n  toNewPrivateKey: PrivateKey;\n}): Promise<TransactionResponse> {\n  const { aptosConfig, fromAccount, toNewPrivateKey } = args;\n  const accountInfo = await getInfo({\n    aptosConfig,\n    accountAddress: fromAccount.accountAddress,\n  });\n\n  const newAccount = Account.fromPrivateKey({ privateKey: toNewPrivateKey, legacy: true });\n\n  const challenge = new RotationProofChallenge({\n    sequenceNumber: BigInt(accountInfo.sequence_number),\n    originator: fromAccount.accountAddress,\n    currentAuthKey: AccountAddress.from(accountInfo.authentication_key),\n    newPublicKey: newAccount.publicKey,\n  });\n\n  // Sign the challenge\n  const challengeHex = challenge.bcsToBytes();\n  const proofSignedByCurrentPrivateKey = fromAccount.sign(challengeHex);\n  const proofSignedByNewPrivateKey = newAccount.sign(challengeHex);\n\n  // Generate transaction\n  const rawTxn = await generateTransaction({\n    aptosConfig,\n    sender: fromAccount.accountAddress,\n    data: {\n      function: \"0x1::account::rotate_authentication_key\",\n      functionArguments: [\n        new U8(fromAccount.signingScheme.valueOf()), // from scheme\n        MoveVector.U8(fromAccount.publicKey.toUint8Array()),\n        new U8(newAccount.signingScheme.valueOf()), // to scheme\n        MoveVector.U8(newAccount.publicKey.toUint8Array()),\n        MoveVector.U8(proofSignedByCurrentPrivateKey.toUint8Array()),\n        MoveVector.U8(proofSignedByNewPrivateKey.toUint8Array()),\n      ],\n    },\n  });\n  const pendingTxn = await signAndSubmitTransaction({\n    aptosConfig,\n    signer: fromAccount,\n    transaction: rawTxn,\n  });\n  return pendingTxn;\n}\n"],"mappings":"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","names":["sha3Hash","isoBase64URL","p256","base64URLStringToBuffer","startAuthentication","generateAuthenticationOptions","generateTransaction","args","payload","buildTransactionPayload","buildRawTransaction","aptosConfig","data","generateTransactionPayloadData","generateTransactionPayload","sender","options","feePayerAddress","isFeePayerTransactionInput","AccountAddress","isMultiAgentTransactionInput","secondarySignerAddresses","buildTransaction","getSigningMessage","transaction","generateSigningMessage","signTransaction","sign","simulateTransaction","signerPublicKey","secondarySignersPublicKeys","feePayerPublicKey","signedTransaction","generateSignedTransactionForSimulation","postAptosFullNode","submitTransaction","generateSignedTransaction","signAndSubmitTransaction","signer","authenticator","publicPackageTransaction","account","metadataBytes","moduleBytecode","totalByteCode","bytecode","MoveVector","rotateAuthKey","fromAccount","toNewPrivateKey","accountInfo","getInfo","newAccount","Account","challengeHex","RotationProofChallenge","proofSignedByCurrentPrivateKey","proofSignedByNewPrivateKey","rawTxn","U8","generateTransactionPayload","args","isScriptDataInput","generateTransactionPayloadScript","moduleAddress","moduleName","functionName","getFunctionParts","functionAbi","memoizeAsync","fetchEntryFunctionAbi","generateTransactionPayloadWithABI","typeArguments","standardizeTypeTags","functionArguments","arg","i","convertArgument","entryFunctionPayload","EntryFunction","multisigAddress","AccountAddress","TransactionPayloadMultiSig","MultiSig","MultiSigTransactionPayload","TransactionPayloadEntryFunction","TransactionPayloadScript","Script","Hex","generateRawTransaction","aptosConfig","sender","payload","options","feePayerAddress","getChainId","NetworkToChainId","getLedgerInfo","getGasUnitPrice","getGasPriceEstimation","chainId","gasEstimate","getSequenceNumber","getInfo","sequenceNumber","seqNumber","maxGasAmount","gasUnitPrice","expireTimestamp","DEFAULT_MAX_GAS_AMOUNT","DEFAULT_TXN_EXP_SEC_FROM_NOW","RawTransaction","ChainId","buildTransaction","rawTxn","signers","signer","generateSignedTransactionForSimulation","signerPublicKey","transaction","secondarySignersPublicKeys","feePayerPublicKey","accountAuthenticator","getAuthenticatorForSimulation","transactionToSign","FeePayerRawTransaction","secondaryAccountAuthenticators","publicKey","feePayerAuthenticator","transactionAuthenticator","TransactionAuthenticatorFeePayer","SignedTransaction","MultiAgentRawTransaction","TransactionAuthenticatorMultiAgent","AccountAuthenticatorEd25519","TransactionAuthenticatorEd25519","AccountAuthenticatorSingleKey","TransactionAuthenticatorSingleSender","AnyPublicKey","Ed25519PublicKey","AnySignature","Ed25519Signature","Secp256k1PublicKey","Secp256k1Signature","sign","message","generateSigningMessage","signerSignature","signWithPasskey","credentialId","timeout","rpID","Secp256r1PublicKey","allowCredentials","isoBase64URL","deriveTransactionType","signingMessage","getSigningMessage","challenge","sha3Hash","authOptions","generateAuthenticationOptions","authenticatorAssertionResponse","startAuthentication","clientDataJSON","authenticatorData","signature","signatureCompact","p256","base64URLStringToBuffer","webAuthnSignature","WebAuthnSignature","Secp256r1Signature","getAuthenticatorForWebAuthn","signatureObj","generateSignedTransaction","senderAuthenticator","additionalSignersAuthenticators","transactionToSubmit","generateMultiSignersSignedTransaction","AccountAuthenticatorMultiKey","txAuthenticatorFeePayer","multiAgentAuthenticator","hash","RAW_TRANSACTION_SALT","RAW_TRANSACTION_WITH_DATA_SALT","prefix","body","mergedArray"]}