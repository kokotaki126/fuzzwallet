{"version":3,"sources":["../../src/core/crypto/secp256r1.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { sha3_256 } from \"@noble/hashes/sha3\";\nimport { p256 } from \"@noble/curves/p256\";\nimport { bufferToBase64URLString } from \"@simplewebauthn/browser\";\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport { PrivateKey, PublicKey, Signature } from \"./asymmetricCrypto\";\nimport { Deserializer, Serializer } from \"../../bcs\";\nimport { Hex } from \"../hex\";\nimport { HexInput } from \"../../types\";\nimport type { WebAuthnSignature } from \"./webauthn\";\n\n/**\n * Represents the Secp256r1 public key\n *\n * Secp256r1 authentication key is represented in the SDK as `AnyPublicKey`.  It is used to verify WebAuthnSignatures.\n */\nexport class Secp256r1PublicKey extends PublicKey {\n  // Secp256r1 ecdsa public keys contain a prefix indicating compression and two 32-byte coordinates.\n  static readonly LENGTH: number = 65;\n\n  // Hex value of the public key\n  private readonly key: Hex;\n\n  /**\n   * Create a new PublicKey instance from a Uint8Array or String.\n   *\n   * @param hexInput A HexInput (string or Uint8Array)\n   */\n  constructor(hexInput: HexInput) {\n    super();\n\n    const hex = Hex.fromHexInput(hexInput);\n    if (hex.toUint8Array().length !== Secp256r1PublicKey.LENGTH) {\n      throw new Error(`PublicKey length should be ${Secp256r1PublicKey.LENGTH}`);\n    }\n    this.key = hex;\n  }\n\n  /**\n   * Get the public key in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the public key\n   */\n  toUint8Array(): Uint8Array {\n    return this.key.toUint8Array();\n  }\n\n  /**\n   * Get the public key as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the public key\n   */\n  toString(): string {\n    return this.key.toString();\n  }\n\n  /**\n   * Verifies a signed data with a public key\n   *\n   * @param args.message message\n   * @param args.signature The signature\n   * @returns true if the signature is valid\n   */\n  verifySignature(args: { message: HexInput; signature: Secp256r1Signature }): boolean {\n    const { message, signature } = args;\n\n    const msgHex = Hex.fromHexInput(message).toUint8Array();\n    const sha3Message = sha256(msgHex);\n    const rawSignature = signature.toUint8Array();\n    return p256.verify(rawSignature, sha3Message, this.toUint8Array());\n  }\n\n  /**\n   * Verifies a signed data with a public key\n   *\n   * @param args.message message\n   * @param args.signature The signature\n   * @returns true if the signature is valid\n   */\n  verifyWebAuthnSignature(args: { message: HexInput; signature: WebAuthnSignature }): boolean {\n    const { message, signature } = args;\n\n    if (!(signature.paar.signature.signature instanceof Secp256r1Signature)) {\n      throw new Error(\"Attestation signature is not a Secp256r1Signature\");\n    }\n\n    // Check challenge\n    const { challenge } = signature.getCollectedClientData();\n\n    const messageBase64URLString = bufferToBase64URLString(Hex.fromHexInput(message).toUint8Array());\n    if (challenge !== messageBase64URLString) {\n      return false;\n    }\n\n    // Get verification data.\n    const verificationData = signature.getVerificationData();\n\n    // Verify the the signature is the signed verification data.\n    return this.verifySignature({ message: verificationData, signature: signature.paar.signature.signature });\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.key.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Secp256r1PublicKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Secp256r1PublicKey(bytes);\n  }\n\n  static load(deserializer: Deserializer): Secp256r1PublicKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Secp256r1PublicKey(bytes);\n  }\n}\n\n/**\n * A Secp256r1 ecdsa private key - this is only used for test purposes as signing is done via passkeys\n */\nexport class Secp256r1PrivateKey extends PrivateKey {\n  /**\n   * Length of Secp256r1 ecdsa private key\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * The private key bytes\n   * @private\n   */\n  private readonly key: Hex;\n\n  /**\n   * Create a new PrivateKey instance from a Uint8Array or String.\n   *\n   * @param hexInput A HexInput (string or Uint8Array)\n   */\n  constructor(hexInput: HexInput) {\n    super();\n\n    const privateKeyHex = Hex.fromHexInput(hexInput);\n    if (privateKeyHex.toUint8Array().length !== Secp256r1PrivateKey.LENGTH) {\n      throw new Error(`PrivateKey length should be ${Secp256r1PrivateKey.LENGTH}`);\n    }\n\n    this.key = privateKeyHex;\n  }\n\n  /**\n   * Get the private key in bytes (Uint8Array).\n   *\n   * @returns\n   */\n  toUint8Array(): Uint8Array {\n    return this.key.toUint8Array();\n  }\n\n  /**\n   * Get the private key as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the private key\n   */\n  toString(): string {\n    return this.key.toString();\n  }\n\n  /**\n   * Sign the given message with the private key.\n   *\n   * @param message in HexInput format\n   * @returns Signature\n   */\n  sign(message: HexInput): Secp256r1Signature {\n    const msgHex = Hex.fromHexInput(message);\n    const sha3Message = sha3_256(msgHex.toUint8Array());\n    const signature = p256.sign(sha3Message, this.key.toUint8Array());\n    return new Secp256r1Signature(signature.toCompactRawBytes());\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Secp256r1PrivateKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Secp256r1PrivateKey(bytes);\n  }\n\n  /**\n   * Generate a new random private key.\n   *\n   * @returns Secp256r1PrivateKey\n   */\n  static generate(): Secp256r1PrivateKey {\n    const hexInput = p256.utils.randomPrivateKey();\n    return new Secp256r1PrivateKey(hexInput);\n  }\n\n  /**\n   * Derive the Secp256r1PublicKey from this private key.\n   *\n   * @returns Secp256r1PublicKey\n   */\n  publicKey(): Secp256r1PublicKey {\n    const bytes = p256.getPublicKey(this.key.toUint8Array(), false);\n    return new Secp256r1PublicKey(bytes);\n  }\n}\n\n/**\n * A signature of a message signed using an Secp256r1 ecdsa private key\n */\nexport class Secp256r1Signature extends Signature {\n  /**\n   * Secp256r1 ecdsa signatures are 256-bit.\n   */\n  static readonly LENGTH = 64;\n\n  /**\n   * The signature bytes\n   * @private\n   */\n  private readonly data: Hex;\n\n  /**\n   * Create a new Signature instance from a Uint8Array or String.  It will convert the signature to its canonical if needed.\n   *\n   * @param hexInput A HexInput (string or Uint8Array)\n   */\n  constructor(hexInput: HexInput) {\n    super();\n\n    const hex = Hex.fromHexInput(hexInput);\n    if (hex.toUint8Array().length !== Secp256r1Signature.LENGTH) {\n      throw new Error(`Signature length should be ${Secp256r1Signature.LENGTH}, recieved ${hex.toUint8Array().length}`);\n    }\n    const signature = p256.Signature.fromCompact(hexInput).normalizeS().toCompactRawBytes();\n    this.data = Hex.fromHexInput(signature);\n  }\n\n  /**\n   * Get the signature in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the signature\n   */\n  toUint8Array(): Uint8Array {\n    return this.data.toUint8Array();\n  }\n\n  /**\n   * Get the signature as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the signature\n   */\n  toString(): string {\n    return this.data.toString();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.data.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Secp256r1Signature {\n    const hex = deserializer.deserializeBytes();\n    return new Secp256r1Signature(hex);\n  }\n\n  static load(deserializer: Deserializer): Secp256r1Signature {\n    const bytes = deserializer.deserializeBytes();\n    return new Secp256r1Signature(bytes);\n  }\n}\n"],"mappings":"gGAGA,OAAS,YAAAA,MAAgB,qBACzB,OAAS,QAAAC,MAAY,qBACrB,OAAS,2BAAAC,MAA+B,0BACxC,OAAS,UAAAC,MAAc,uBAYhB,IAAMC,EAAN,MAAMA,UAA2BC,CAAU,CAYhD,YAAYC,EAAoB,CAC9B,MAAM,EAEN,IAAMC,EAAMC,EAAI,aAAaF,CAAQ,EACrC,GAAIC,EAAI,aAAa,EAAE,SAAWH,EAAmB,OACnD,MAAM,IAAI,MAAM,8BAA8BA,EAAmB,MAAM,EAAE,EAE3E,KAAK,IAAMG,CACb,CAOA,cAA2B,CACzB,OAAO,KAAK,IAAI,aAAa,CAC/B,CAOA,UAAmB,CACjB,OAAO,KAAK,IAAI,SAAS,CAC3B,CASA,gBAAgBE,EAAqE,CACnF,GAAM,CAAE,QAAAC,EAAS,UAAAC,CAAU,EAAIF,EAEzBG,EAASJ,EAAI,aAAaE,CAAO,EAAE,aAAa,EAChDG,EAAcC,EAAOF,CAAM,EAC3BG,EAAeJ,EAAU,aAAa,EAC5C,OAAOK,EAAK,OAAOD,EAAcF,EAAa,KAAK,aAAa,CAAC,CACnE,CASA,wBAAwBJ,EAAoE,CAC1F,GAAM,CAAE,QAAAC,EAAS,UAAAC,CAAU,EAAIF,EAE/B,GAAI,EAAEE,EAAU,KAAK,UAAU,qBAAqBM,GAClD,MAAM,IAAI,MAAM,mDAAmD,EAIrE,GAAM,CAAE,UAAAC,CAAU,EAAIP,EAAU,uBAAuB,EAEjDQ,EAAyBC,EAAwBZ,EAAI,aAAaE,CAAO,EAAE,aAAa,CAAC,EAC/F,GAAIQ,IAAcC,EAChB,MAAO,GAIT,IAAME,EAAmBV,EAAU,oBAAoB,EAGvD,OAAO,KAAK,gBAAgB,CAAE,QAASU,EAAkB,UAAWV,EAAU,KAAK,UAAU,SAAU,CAAC,CAC1G,CAEA,UAAUW,EAA8B,CACtCA,EAAW,eAAe,KAAK,IAAI,aAAa,CAAC,CACnD,CAEA,OAAO,YAAYC,EAAgD,CACjE,IAAMC,EAAQD,EAAa,iBAAiB,EAC5C,OAAO,IAAInB,EAAmBoB,CAAK,CACrC,CAEA,OAAO,KAAKD,EAAgD,CAC1D,IAAMC,EAAQD,EAAa,iBAAiB,EAC5C,OAAO,IAAInB,EAAmBoB,CAAK,CACrC,CACF,EAlGapB,EAEK,OAAiB,GAF5B,IAAMqB,EAANrB,EAuGMsB,EAAN,MAAMA,UAA4BC,CAAW,CAiBlD,YAAYrB,EAAoB,CAC9B,MAAM,EAEN,IAAMsB,EAAgBpB,EAAI,aAAaF,CAAQ,EAC/C,GAAIsB,EAAc,aAAa,EAAE,SAAWF,EAAoB,OAC9D,MAAM,IAAI,MAAM,+BAA+BA,EAAoB,MAAM,EAAE,EAG7E,KAAK,IAAME,CACb,CAOA,cAA2B,CACzB,OAAO,KAAK,IAAI,aAAa,CAC/B,CAOA,UAAmB,CACjB,OAAO,KAAK,IAAI,SAAS,CAC3B,CAQA,KAAKlB,EAAuC,CAC1C,IAAME,EAASJ,EAAI,aAAaE,CAAO,EACjCG,EAAcgB,EAASjB,EAAO,aAAa,CAAC,EAC5CD,EAAYK,EAAK,KAAKH,EAAa,KAAK,IAAI,aAAa,CAAC,EAChE,OAAO,IAAII,EAAmBN,EAAU,kBAAkB,CAAC,CAC7D,CAEA,UAAUW,EAA8B,CACtCA,EAAW,eAAe,KAAK,aAAa,CAAC,CAC/C,CAEA,OAAO,YAAYC,EAAiD,CAClE,IAAMC,EAAQD,EAAa,iBAAiB,EAC5C,OAAO,IAAIG,EAAoBF,CAAK,CACtC,CAOA,OAAO,UAAgC,CACrC,IAAMlB,EAAWU,EAAK,MAAM,iBAAiB,EAC7C,OAAO,IAAIU,EAAoBpB,CAAQ,CACzC,CAOA,WAAgC,CAC9B,IAAMkB,EAAQR,EAAK,aAAa,KAAK,IAAI,aAAa,EAAG,EAAK,EAC9D,OAAO,IAAIS,EAAmBD,CAAK,CACrC,CACF,EAvFaE,EAIK,OAAiB,GAJ5B,IAAMI,EAANJ,EA4FMK,EAAN,MAAMA,UAA2BC,CAAU,CAiBhD,YAAY1B,EAAoB,CAC9B,MAAM,EAEN,IAAMC,EAAMC,EAAI,aAAaF,CAAQ,EACrC,GAAIC,EAAI,aAAa,EAAE,SAAWwB,EAAmB,OACnD,MAAM,IAAI,MAAM,8BAA8BA,EAAmB,MAAM,cAAcxB,EAAI,aAAa,EAAE,MAAM,EAAE,EAElH,IAAMI,EAAYK,EAAK,UAAU,YAAYV,CAAQ,EAAE,WAAW,EAAE,kBAAkB,EACtF,KAAK,KAAOE,EAAI,aAAaG,CAAS,CACxC,CAOA,cAA2B,CACzB,OAAO,KAAK,KAAK,aAAa,CAChC,CAOA,UAAmB,CACjB,OAAO,KAAK,KAAK,SAAS,CAC5B,CAEA,UAAUW,EAA8B,CACtCA,EAAW,eAAe,KAAK,KAAK,aAAa,CAAC,CACpD,CAEA,OAAO,YAAYC,EAAgD,CACjE,IAAMhB,EAAMgB,EAAa,iBAAiB,EAC1C,OAAO,IAAIQ,EAAmBxB,CAAG,CACnC,CAEA,OAAO,KAAKgB,EAAgD,CAC1D,IAAMC,EAAQD,EAAa,iBAAiB,EAC5C,OAAO,IAAIQ,EAAmBP,CAAK,CACrC,CACF,EA3DaO,EAIK,OAAS,GAJpB,IAAMd,EAANc","names":["sha3_256","p256","bufferToBase64URLString","sha256","_Secp256r1PublicKey","PublicKey","hexInput","hex","Hex","args","message","signature","msgHex","sha3Message","sha256","rawSignature","p256","Secp256r1Signature","challenge","messageBase64URLString","bufferToBase64URLString","verificationData","serializer","deserializer","bytes","Secp256r1PublicKey","_Secp256r1PrivateKey","PrivateKey","privateKeyHex","sha3_256","Secp256r1PrivateKey","_Secp256r1Signature","Signature"]}